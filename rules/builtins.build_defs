# Contains declarations of built-in functions & objects


# Do not change the order of arguments to this function without updating the iota in targets.go to match it.
def build_rule(name:str, cmd:str|dict='', test_cmd:str|dict='', debug_cmd:str='', srcs:list|dict=None, data:list|dict=None,
               debug_data:list|dict=None, outs:list|dict=None, deps:list=None, exported_deps:list=None, secrets:list|dict=None,
               tools:str|list|dict=None, test_tools:str|list|dict=None, debug_tools:str|list|dict=None, labels:list=None,
               visibility:list=CONFIG.DEFAULT_VISIBILITY, hashes:list=None, binary:bool=False, test:bool=False,
               test_only:bool=CONFIG.DEFAULT_TESTONLY, building_description:str=None, needs_transitive_deps:bool=False,
               output_is_complete:bool=False, sandbox:bool=CONFIG.BUILD_SANDBOX, test_sandbox:bool=CONFIG.TEST_SANDBOX,
               no_test_output:bool=False, flaky:bool|int=0, build_timeout:int|str=0, test_timeout:int|str=0, pre_build:function=None,
               post_build:function=None, requires:list=None, provides:dict=None, licences:list=CONFIG.DEFAULT_LICENCES,
               test_outputs:list=None, system_srcs:list=None, stamp:bool=False, tag:str='', optional_outs:list=None, progress:bool=False,
               size:str=None, _urls:list=None, internal_deps:list=None, pass_env:list=None, local:bool=False, output_dirs:list=[],
               exit_on_error:bool=CONFIG.EXIT_ON_ERROR, entry_points:dict={}, env:dict={}, _file_content:str=None,
               _subrepo:bool=False):
    pass

def chr(i:int) -> str:
    pass
def ord(c:str) -> int:
    pass
def len(obj:list|dict|str) -> int:
    pass
def enumerate(seq:list):
    pass
def zip(args):
    pass

def join(self:str, seq:list) -> str:
    pass
def split(self:str, on:str=' ') -> list:
    pass
def replace(self:str, old:str, new:str):
    pass
def partition(self:str, sep:str) -> list:
    pass
def rpartition(self:str, sep:str) -> list:
    pass
def startswith(self:str, s:str) -> bool:
    pass
def endswith(self:str, s:str) -> bool:
    pass
def format(self:str) -> str:
    pass
def lstrip(self:str, cutset:str=' \n') -> str:
    pass
def rstrip(self:str, cutset:str=' \n') -> str:
    pass
def strip(self:str, cutset:str=' \n') -> str:
    pass
def removeprefix(self:str, prefix:str) -> str:
    pass
def removesuffix(self:str, suffix:str) -> str:
    pass
def find(self:str, needle:str) -> int:
    pass
def rfind(self:str, needle:str) -> int:
    pass
def count(self:str, needle:str) -> int:
    pass
def upper(self:str) -> str:
    pass
def lower(self:str) -> str:
    pass

def fail(msg:str):
    pass

def subinclude(target:str|list):
    pass
def load(target:str, names:str=None):
    pass
def subrepo(name:str, dep:str='', path:str=None, config:str=None, bazel_compat:bool=False, arch:str=None,
    plugin:bool=False, package_root:str=None):
    pass


def isinstance(obj, types:function|list) -> bool:
    pass


def range(start:int, stop:int=None, step:int=1) -> str:
    pass

def any(seq:list) -> bool:
    pass

def all(seq:list) -> bool:
    pass

def min(seq:list, key:function=None):
    pass

def max(seq:list, key:function=None):
    pass

def filter(filter:function, seq:list):
    pass

def map(mapper:function, seq:list):
    pass

def reduce(reducer:function, seq:list, initializer=None):
    pass

def bool(b) -> bool:
    pass
def int(s:str) -> int:
    pass
def str(s) -> str:
    pass
def list(l):
    fail('list is not callable')
def dict(d):
    fail('dict is not callable')
def callable(f:function) -> bool:
    return isinstance(f, callable)


def glob(include:list|str, exclude:list|str&excludes=[], hidden:bool=CONFIG.BAZEL_COMPATIBILITY, include_symlinks:bool=False, allow_empty:bool=False) -> list:
    pass


def package():
    pass

def sorted(seq:list) -> list:
    pass

def reversed(seq:list) -> list:
    pass

def get(self:dict, key:str, default=None):
    pass
def setdefault(self:config, key:str, default=None) -> config:
    if key in self:
        return self[key]
    self[key] = default
    return default
def config_get(self:config, key:str, default=None) -> config:
    pass


def get_base_path(label:str=None, subinclude_context:bool=None) -> str:
    pass
def package_name(label:str=None, subinclude_context:bool=None) -> str:
    pass
def subrepo_name(label:str=None, subinclude_context:bool=None) -> str:
    pass
def looks_like_build_label(label:str) -> bool:
    pass

def canonicalise(label:str, subinclude_context:bool=None) -> str:
    """Converts the given build label to its full form.

    For example:
      //package:target -> //package:target
      //package -> //package:package
      :target -> //current_package:target
    """
    pass

def tag(name:str, tag:str):
    """Applies a tag to a build target name, similar to the `tag` param on build_rule().

    For example:
        tag("name", "foo") -> "_name#foo"
        tag("_name#foo", "bar") -> "_name#foo_bar"
    """
    pass


def keys(self:dict) -> list:
    pass
def values(self:dict) -> list:
    pass
def items(self:dict) -> list:
    pass
def copy(self:dict) -> dict:
    pass


def git_branch(short:bool=True) -> str:
    fail('Disabled in config')
def git_commit() -> str:
    fail('Disabled in config')
def git_show(fmt:str) -> str:
    fail('Disabled in config')
def git_state(clean_label:str="clean", dirty_label:str="dirty") -> str:
    fail('Disabled in config')

def debug(args):
    pass
def info(args):
    pass
def notice(args):
    pass
def warning(args):
    pass
def error(args):
    pass
def fatal(args):
    pass

log = {
    'debug': debug,
    'info': info,
    'notice': notice,
    'warning': warning,
    'error': error,
    'fatal': fatal,
}


def join_path(paths:str) -> str:
    pass  # Has to be implemented natively since it's varargs.


def split_path(p:str) -> list:
    before, _, after = p.rpartition('/')
    return before, after


def splitext(p:str) -> list:
    before, dot, after = p.rpartition('.')
    return (before, dot + after) if before else (after, '')


def basename(p:str) -> str:
    """Returns the final component of a pathname"""
    _, _, after = p.rpartition('/')
    return after


def dirname(p:str) -> str:
    """Returns the directory component of a pathname"""
    before, _, after = p.rpartition('/')
    return before


# Post-build callback functions.
def get_labels(name:str, prefix:str, all:bool=False, transitive=True) -> list:
    pass
def has_label(name:str, prefix:str, all:bool=False) -> bool:
    return len(get_labels(name, prefix, all)) > 0
def add_label(name:str, label:str):
    pass
def add_dep(target:str, dep:str, exported:bool=False):
    pass
def add_exported_dep(target:str, dep:str):
    add_dep(target, dep, True)
def add_data(target:str, datum:str|list|dict):
    pass
def add_out(target:str, name:str, out:str=''):
    pass
def get_outs(target:str):
    pass
def get_named_outs(target:str) -> dict:
    pass
def add_entry_point(target:str, name:str, out:str):
    pass
def get_entry_points(target:str) -> dict:
    pass
def add_licence(target:str, licence:str):
    pass
def get_licences(target:str):
    pass
def get_command(target:str, config:str=''):
    pass
def set_command(target:str, config:str, command:str=''):
    pass


# N.B. This should really be limited so it's only visible when Bazel compat is on,
#      but we currently don't alter the builtins for that scenario.
def licenses(licences):
    """Sets the default licences for the package."""
    assert CONFIG.BAZEL_COMPATIBILITY, 'licenses() can only be called in Bazel compat mode'
    package(default_licences = licences)


def json(value) -> str:
    """Returns a JSON-formatted representation of a plz value"""
    pass


def breakpoint():
    """Breaks into an interactive debugging session."""
    pass

def is_semver(s:str) -> bool:
    """Returns true if the given string is a semantic version number (either with or without
    a leading v), or false if not.
    """
    pass

def semver_check(version:str, constraint:str) -> bool:
    pass


# Returns build label
# https://github.com/thought-machine/please/blob/v17.3.1/src/core/build_label.go#L159
# https://github.com/thought-machine/please/blob/6cc3d7689ad78c667618b5ca9d089630864cd140/src/core/build_input.go#L226
def buildlabel(
    label: str | list = "",
    path: str = "",
    target: str = "",
    subtarget: str = "",
    subrepo: str = "",
    pkg: str = "",
    package: str = "",
    out: str = "",
    name: str = "",
    relative=False,
    aslist=True,
):
    """Compose a build label

    Args:
        label (str|list): please label fallback into path if component cannot be guessed
        path (str): classical UNIX path to package, last component can be '...'
        target (str): target name, if empty will default to package name
        subtarget (str): target named output
        subrepo (str): subrepo name
        pkg (str): alias path parameter
        package (str): alias path parameter
        out (str): alias subtarget parameter
        name (str): alias target parameter
        relative (bool): keep a relative path?
        aslist (bool): return label in []
    Return:
        (str): build label
    """
    if isinstance(label, list):
        res = map(
            lambda l: buildlabel(
                label=l,
                path=path,
                target=target,
                subtarget=subtarget,
                subrepo=subrepo,
                pkg=pkg,
                package=package,
                out=out,
                name=name,
                relative=relative,
                aslist=False,
            ),
            label,
        )
        return res[0] if (len(res) == 1) and not aslist else res

    _res_alias = lambda als: reduce(lambda x, y: x if x else y, als)
    _set_cnt = lambda l: reduce(lambda x, y: x + y, map(lambda x: 1 if x else 0, l), 0)
    path = [path, pkg, package]
    target = [target, name]
    subtarget = [subtarget, out]
    subrepo = [subrepo]

    if _set_cnt(path) > 1:
        return fail("can only set one of [path, pkg, package]")
    if _set_cnt(target) > 1:
        return fail("can only set one of [target, name]")
    if _set_cnt(subtarget) > 1:
        return fail("can only set one of [subtarget, out]")
    if _set_cnt(subrepo) > 1:
        return fail("can only set one of [subrepo]")

    if label == "*":  # special for vis
        return ["PUBLIC"] if aslist else "PUBLIC"

    # split label
    if label.startswith("///"):
        label = "@" + label[3:]
    if "|" in label:
        label, lbl_subtarget = label.split("|")
        subtarget += [lbl_subtarget]
    if ":" in label:
        label, lbl_target = label.split(":")
        target += [lbl_target]
    if "//" in label:
        label, lbl_path = label.split("//")
        path += [f"/{lbl_path}"]
    if "@" in label:
        label, lbl_subrepo = label.split("@")
        subrepo += [f"/{lbl_subrepo}"]
    path += [label]  # reminder as path

    path = _res_alias(path)
    target = _res_alias(target)
    subtarget = _res_alias(subtarget)
    subrepo = _res_alias(subrepo)

    _prefix = lambda pre, s: pre + s.removeprefix(pre)
    _prefix_if = lambda pre, s: _prefix(pre, s) if s else ""
    _globalize_rel_path = lambda p, glf: (
        p if p.startswith("/") else (glf() + _prefix("/", p))
    )
    _resolve_path_or_global = lambda p, glf: (
        "/".join(reduce(_resolve_path, _globalize_rel_path(p, glf).split("/"), [""]))
        if p
        else glf()
    )

    def _resolve_path(acc, p):
        if p == ".":
            return acc
        elif p == "..":
            return (
                acc[:-1] if len(acc) > 1 else acc
            )  # len > 1 to avoid a please interpreter bug
        else:
            return acc + ([p] if p else [])

    path = path.replace("//", "/")
    subrepo = subrepo.replace("///", "/")

    if not relative:
        path = _resolve_path_or_global(path, get_base_path)
        subrepo = _resolve_path_or_global(subrepo, subrepo_name)

    path = path.removeprefix("/")
    subrepo = subrepo.removeprefix("/")

    subrepo = _prefix("///", subrepo)
    path = _prefix("//", path)
    target = _prefix_if(":", target)
    subtarget = _prefix_if("|", subtarget)

    label = _prefix("///", subrepo + path + target + subtarget)
    return [label] if aslist else label


# buildlabel aliases
bl = buildlabel
subdir = buildlabel
vis = buildlabel
